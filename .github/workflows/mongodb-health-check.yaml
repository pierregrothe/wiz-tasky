name: "MongoDB Health Check via SSM"

on:
  push:
    branches:
      - dev
      - staging
      - main
  workflow_dispatch: {}

jobs:
  mongodb-health-check:
    name: "Check MongoDB Status"
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      # Dynamically select AWS credentials and TF token based on branch.
      TF_WORKSPACE: ${{ github.ref == 'refs/heads/staging' && 'wiz-tasky-staging' || 'wiz-tasky-dev' }}
      TF_TOKEN_app_terraform_io: ${{ github.ref == 'refs/heads/staging' && secrets.TF_API_TOKEN_STAGING || secrets.TF_API_TOKEN_DEV }}
      AWS_ACCESS_KEY_ID: ${{ github.ref == 'refs/heads/staging' && secrets.AWS_ACCESS_KEY_ID_STAGING || github.ref == 'refs/heads/main' && secrets.AWS_ACCESS_KEY_ID_PROD || secrets.AWS_ACCESS_KEY_ID_DEV }}
      AWS_SECRET_ACCESS_KEY: ${{ github.ref == 'refs/heads/staging' && secrets.AWS_SECRET_ACCESS_KEY_STAGING || github.ref == 'refs/heads/main' && secrets.AWS_SECRET_ACCESS_KEY_PROD || secrets.AWS_SECRET_ACCESS_KEY_DEV }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: "1.10.5"

      # Write Terraform Cloud credentials file non-interactively.
      - name: Write Terraform Credentials File
        run: |
          mkdir -p ~/.terraform.d
          cat <<EOF > ~/.terraform.d/credentials.tfrc.json
          {
            "credentials": {
              "app.terraform.io": {
                "token": "${{ env.TF_TOKEN_app_terraform_io }}"
              }
            }
          }
          EOF
          cat ~/.terraform.d/credentials.tfrc.json

      - name: Terraform Init
        run: terraform init

      # Retrieve the MongoDB instance ID using JSON output and jq.
      - name: Retrieve MongoDB Instance ID
        id: mongodb
        run: |
          # Capture the full output (including any debug messages).
          RAW_OUTPUT=$(terraform output -raw mongodb_instance_id 2>/dev/null)
          echo "Raw output: $RAW_OUTPUT"
          # Extract only the first match for an EC2 instance ID (e.g., "i-123abc...").
          INSTANCE_ID=$(echo "$RAW_OUTPUT" | grep -oE 'i-[0-9a-f]+' | head -n1)
          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: Could not extract a valid instance ID from the output."
            exit 1
          fi
          echo "MongoDB Instance ID: ${INSTANCE_ID}"
          echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT

      # Wait for the MongoDB instance to appear in SSM as Online.
      - name: Wait for MongoDB Instance to be Registered in SSM
        run: |
          INSTANCE_ID="${{ steps.mongodb.outputs.instance_id }}"
          echo "Checking SSM registration for instance: $INSTANCE_ID"
          for attempt in {1..12}; do
            SSM_STATUS=$(aws ssm describe-instance-information --region $AWS_REGION --query "InstanceInformationList[?InstanceId=='${INSTANCE_ID}'].PingStatus" --output text)
            echo "Attempt ${attempt}: SSM PingStatus = $SSM_STATUS"
            if [ "$SSM_STATUS" = "Online" ]; then
              echo "Instance $INSTANCE_ID is registered and online in SSM."
              exit 0
            fi
            sleep 5
          done
          echo "Error: Instance $INSTANCE_ID did not register in SSM within the expected time."
          exit 1

      # Send an SSM command to run the MongoDB ping command using mongosh.
      - name: Send SSM Command to MongoDB Instance
        id: send_command
        run: |
          INSTANCE_ID="${{ steps.mongodb.outputs.instance_id }}"
          echo "Sending SSM command to instance: $INSTANCE_ID"
          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=instanceids,Values=${INSTANCE_ID}" \
            --parameters '{"commands": ["mongosh --quiet --eval \"db.runCommand({ ping: 1 })\""]}' \
            --timeout-seconds 30 \
            --query "Command.CommandId" \
            --output text \
            --region $AWS_REGION)
          echo "SSM Command ID: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

      # Wait for the SSM command to finish and validate MongoDB response.
      - name: Wait for SSM Command and Validate MongoDB Response
        run: |
          INSTANCE_ID="${{ steps.mongodb.outputs.instance_id }}"
          COMMAND_ID="${{ steps.send_command.outputs.command_id }}"
          echo "Waiting for SSM command $COMMAND_ID on instance $INSTANCE_ID..."
          for attempt in {1..12}; do
            OUTPUT=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardOutputContent" \
              --output text \
              --region $AWS_REGION)
            echo "Attempt ${attempt}: $OUTPUT"
            if echo "$OUTPUT" | grep -q '"ok" : 1'; then
              echo "Success: MongoDB is up and responding correctly."
              exit 0
            fi
            sleep 5
          done
          echo "Error: MongoDB health check failed."
          exit 1
